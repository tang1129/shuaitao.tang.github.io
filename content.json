{"meta":{"title":"夏了夏天","subtitle":"","description":"","author":"shuaitao.tang","url":"https://tang1129.github.io","root":"/"},"pages":[],"posts":[{"title":"内存对齐问题","slug":"内存对齐问题","date":"2020-08-13T09:21:49.000Z","updated":"2020-08-13T09:23:17.956Z","comments":true,"path":"2020/08/13/内存对齐问题/","link":"","permalink":"https://tang1129.github.io/2020/08/13/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98/","excerpt":"","text":"1 明确几个概念代码分区: 在使用C/C++编程时，我们定义的变量存在于内存中，而内存在C语言的角度上可以分为五大区。局部变量在栈区，静态/全局变量在全局区，动态申请的变量存在于堆区，const修饰的变量/字符常量存在于只读区。无论是什么样的变量，终究在内存中。 CPU取指，译码，执行: 存在于内存中的目的是为了CPU通过总线的进行寻址，取指令，译码，执行取数据，内存与寄存器交互，然后CPU运算，再输出数据至内存。这个过程反复的，高速的执行。 CPU位数： 在计算机中，最小的存储单元为字节(Byte)，理论上任意地址(比如0x20000002，0x20000003，0x2000011…)都可以通过总线进行访问(CPU寻址)，而每次寻址后，传输的数据大小跟CPU位数相关，常见的CPU位数有8位，16位，32位，64位。位数越高，单次操作执行的数据量越大，性能也就越强。 OS位数： 操作系统一般与CPU位数相匹配，32位CPU可以寻址4GB内存空间，可以运行32位的OS。同样，64位的CPU可以运行32位的OS，也可以运行64位的OS。 Compiler： 虽然编译器都是在翻译/编译代码，进行预处理(宏展开，头文件展开)，编译(语法检查等)，汇编(翻译为机器码)，链接(重定位等)这四部分的工作。但是不同的编译器的内部默认设置以及用法会有所差异，常用的有GCC，VS，Clang，MinGW等。 2 指定平台这里的平台指的是三大件：CPU + OS + Compiler 本文中实验的平台是：Intel i7 + ubuntu16.04 + gcc5.4 有了上面的基本概念了解，就可以进行分析了。 3 为什么要内存对齐？原因有两点：CPU每次寻址都是要消费时间的，如果一次取不完数据就要取多次。比如int类型的变量a占4Byte，假设在内存中没有对齐(所谓对齐，指的是内存中数据的首地址是CPU单次获取数据大小的整数倍)，且存放在0x00000003 - 0x00000006处(0x00000003不是4的整数倍)。那么每次取4字节(32位宽总线)的CPU第一次取到[0x00000000 - 0x00000003]，只得到变量a的1/4数据，进而需要进行第二次取数[0x00000004 - 0x00000007]，为了得到int类型的一个变量，却需要两次访问内存，并且还需要拼接处理，性能较低，这是其一 。 有些CPU(ARM架构的)在内存非对齐的情况下，执行二进制代码会崩溃，因为不是所有的硬件平台都能访问任意地址上的任意数据的。倘若代码移植到其他不支持的平台上，不具有可移植性，这是其二 。 若在编译时，将分配的内存进行对齐，单次访问内存就可以获取数据，并且具有平台可移植性。 那谁来把我们编写的结构体，类中的成员变量进行对齐呢？ 当然是编译器(Compiler)。那对齐的规则又是如何呢？ 4 内存对齐规则编译器提供手动指定对齐值的关键字 #pragma pack(N)，可以手动设置对齐的字节数，比如#pragma pack(1），#pragma pack(4)等。这里即为N。 若没有手动指定，那么编译器就会默认将成员变量中最大的类型字节数设置为对齐值：m 1 整体对齐值：首先计算对齐单位 n = min{N,m}，然后整体对齐后的字节数应该为n的倍数，不够的在最后面填补占位。 2 成员对齐值：首个成员的偏置地址(offset) = 0。 假定该成员的类型占字节数 j，那么本成员的偏移地址(offset)：min{n, j}的整数倍。 5 代码实测123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;class Test&#123;public: char c; &#x2F;&#x2F; offset &#x3D; 0x20000000. 区间：[0x20000000,0x2000000] int i; &#x2F;&#x2F;offset &#x3D; min&#123;8,4&#125;的整数倍为0x20000004. 区间：[0x20000004,0x20000007] short s; &#x2F;&#x2F;offset &#x3D; min&#123;8,2&#125;的整数倍,0x20000008. 区间：[0x20000008,0x200009] double d; &#x2F;&#x2F;offset &#x3D; min&#123;8,8&#125;的整数倍,0x20000010. 区间：[0x20000010,0x200017] &#x2F;&#x2F;整体占24字节，并且24 为 min&#123;8,8&#125;的整数倍，故对齐，无需在尾部填充占位。 Test()&#123;&#125; ~Test()&#123;&#125; void fff()&#123;&#125;&#125;;class A&#123; int i; char c1;&#125;;class B: public A&#123; char c2;&#125;;class C: public B&#123; char c3;&#125;;int main()&#123; cout &lt;&lt; sizeof(char) &lt;&lt; endl; &#x2F;&#x2F; 1 cout &lt;&lt; sizeof(short) &lt;&lt; endl; &#x2F;&#x2F; 2 cout &lt;&lt; sizeof(int) &lt;&lt; endl; &#x2F;&#x2F; 4 cout &lt;&lt; sizeof(long) &lt;&lt; endl; &#x2F;&#x2F; 8 cout &lt;&lt; sizeof(double) &lt;&lt; endl; &#x2F;&#x2F; 8 cout &lt;&lt; &quot;sizeof C: &quot; &lt;&lt; sizeof(C) &lt;&lt; endl; &#x2F;&#x2F;先继承，后对齐。相当于对一个大的类进行对齐 Test test; cout &lt;&lt; &quot;Test class: &quot; &lt;&lt; sizeof(Test) &lt;&lt; &quot; &quot; &lt;&lt; sizeof(test) &lt;&lt; endl; return 0;&#125; 以上注释为理论分析。 现在编译，并执行输出看看是否sizeof = 24。 这里使用的GCC中的g++进行编译。 也可以用gcc，不过要链接c++的标准库(-lstdc++)，否则会链接失败。 这里实验结果与理论分析的一致。 另外：如果手动设置#pragma pack(4)，后效果如何呢？ 1234567891011121314#pragma pack(4)class Test&#123;public: char c; &#x2F;&#x2F; offset &#x3D; 0x20000000. 区间：[0x20000000,0x2000000] int i; &#x2F;&#x2F;offset &#x3D; min&#123;4,4&#125;的整数倍为0x20000004. 区间：[0x20000004,0x20000007] short s; &#x2F;&#x2F;offset &#x3D; min&#123;4,2&#125;的整数倍,0x20000008. 区间：[0x20000008,0x200009] double d; &#x2F;&#x2F;offset &#x3D; min&#123;4,8&#125;的整数倍,0x2000000C. 区间：[0x2000000C,0x200013] &#x2F;&#x2F;整体占20字节，并且20 为 min&#123;4,8&#125;的整数倍，故对齐，无需在尾部填充占位。 Test()&#123;&#125; ~Test()&#123;&#125; void fff()&#123;&#125;&#125;;#pragma pack() 查看结果是否为sizeof = 20呢？ 显然，是和分析的一致。 6 总结这里以C++的类为例，进行内存对齐分析。关于C++的内存布局，以及含有virtual函数的类，实际上还会更复杂。简单的就如最基本的类，这和C中的struct是非常类似的。 掌握C++中类的内存对齐，有助于进一步理解C++对象模型。","categories":[],"tags":[]},{"title":"C/C++内存对齐问题","slug":"CC++内存对齐问题","date":"2020-08-11T15:20:28.000Z","updated":"2020-08-13T09:15:47.072Z","comments":true,"path":"2020/08/11/CC++内存对齐问题/","link":"","permalink":"https://tang1129.github.io/2020/08/11/CC++%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98/","excerpt":"","text":"1 明确几个概念代码分区: 在使用C/C++编程时，我们定义的变量存在于内存中，而内存在C语言的角度上可以分为五大区。局部变量在栈区，静态/全局变量在全局区，动态申请的变量存在于堆区，const修饰的变量/字符常量存在于只读区。无论是什么样的变量，终究在内存中。 CPU取指，译码，执行: 存在于内存中的目的是为了CPU通过总线的进行寻址，取指令，译码，执行取数据，内存与寄存器交互，然后CPU运算，再输出数据至内存。这个过程反复的，高速的执行。 CPU位数： 在计算机中，最小的存储单元为字节(Byte)，理论上任意地址(比如0x20000002，0x20000003，0x2000011…)都可以通过总线进行访问(CPU寻址)，而每次寻址后，传输的数据大小跟CPU位数相关，常见的CPU位数有8位，16位，32位，64位。位数越高，单次操作执行的数据量越大，性能也就越强。 OS位数： 操作系统一般与CPU位数相匹配，32位CPU可以寻址4GB内存空间，可以运行32位的OS。同样，64位的CPU可以运行32位的OS，也可以运行64位的OS。 Compiler： 虽然编译器都是在翻译/编译代码，进行预处理(宏展开，头文件展开)，编译(语法检查等)，汇编(翻译为机器码)，链接(重定位等)这四部分的工作。但是不同的编译器的内部默认设置以及用法会有所差异，常用的有GCC，VS，Clang，MinGW等。 2 指定平台这里的平台指的是三大件：CPU + OS + Compiler 本文中实验的平台是：Intel i7 + ubuntu16.04 + gcc5.4 有了上面的基本概念了解，就可以进行分析了。 3 为什么要内存对齐？原因有两点：CPU每次寻址都是要消费时间的，如果一次取不完数据就要取多次。比如int类型的变量a占4Byte，假设在内存中没有对齐(所谓对齐，指的是内存中数据的首地址是CPU单次获取数据大小的整数倍)，且存放在0x00000003 - 0x00000006处(0x00000003不是4的整数倍)。那么每次取4字节(32位宽总线)的CPU第一次取到[0x00000000 - 0x00000003]，只得到变量a的1/4数据，进而需要进行第二次取数[0x00000004 - 0x00000007]，为了得到int类型的一个变量，却需要两次访问内存，并且还需要拼接处理，性能较低，这是其一 。 有些CPU(ARM架构的)在内存非对齐的情况下，执行二进制代码会崩溃，因为不是所有的硬件平台都能访问任意地址上的任意数据的。倘若代码移植到其他不支持的平台上，不具有可移植性，这是其二 。 若在编译时，将分配的内存进行对齐，单次访问内存就可以获取数据，并且具有平台可移植性。 那谁来把我们编写的结构体，类中的成员变量进行对齐呢？ 当然是编译器(Compiler)。那对齐的规则又是如何呢？ 4 内存对齐规则编译器提供手动指定对齐值的关键字 #pragma pack(N)，可以手动设置对齐的字节数，比如#pragma pack(1），#pragma pack(4)等。这里即为N。 若没有手动指定，那么编译器就会默认将成员变量中最大的类型字节数设置为对齐值：m 1 整体对齐值：首先计算对齐单位 n = min{N,m}，然后整体对齐后的字节数应该为n的倍数，不够的在最后面填补占位。 2 成员对齐值：首个成员的偏置地址(offset) = 0。 假定该成员的类型占字节数 j，那么本成员的偏移地址(offset)：min{n, j}的整数倍。 5 代码实测123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;class Test&#123;public: char c; &#x2F;&#x2F; offset &#x3D; 0x20000000. 区间：[0x20000000,0x2000000] int i; &#x2F;&#x2F;offset &#x3D; min&#123;8,4&#125;的整数倍为0x20000004. 区间：[0x20000004,0x20000007] short s; &#x2F;&#x2F;offset &#x3D; min&#123;8,2&#125;的整数倍,0x20000008. 区间：[0x20000008,0x200009] double d; &#x2F;&#x2F;offset &#x3D; min&#123;8,8&#125;的整数倍,0x20000010. 区间：[0x20000010,0x200017] &#x2F;&#x2F;整体占24字节，并且24 为 min&#123;8,8&#125;的整数倍，故对齐，无需在尾部填充占位。 Test()&#123;&#125; ~Test()&#123;&#125; void fff()&#123;&#125;&#125;;class A&#123; int i; char c1;&#125;;class B: public A&#123; char c2;&#125;;class C: public B&#123; char c3;&#125;;int main()&#123; cout &lt;&lt; sizeof(char) &lt;&lt; endl; &#x2F;&#x2F; 1 cout &lt;&lt; sizeof(short) &lt;&lt; endl; &#x2F;&#x2F; 2 cout &lt;&lt; sizeof(int) &lt;&lt; endl; &#x2F;&#x2F; 4 cout &lt;&lt; sizeof(long) &lt;&lt; endl; &#x2F;&#x2F; 8 cout &lt;&lt; sizeof(double) &lt;&lt; endl; &#x2F;&#x2F; 8 cout &lt;&lt; &quot;sizeof C: &quot; &lt;&lt; sizeof(C) &lt;&lt; endl; &#x2F;&#x2F;先继承，后对齐。相当于对一个大的类进行对齐 Test test; cout &lt;&lt; &quot;Test class: &quot; &lt;&lt; sizeof(Test) &lt;&lt; &quot; &quot; &lt;&lt; sizeof(test) &lt;&lt; endl; return 0;&#125; 以上注释为理论分析。 现在编译，并执行输出看看是否sizeof = 24。 这里使用的GCC中的g++进行编译。 也可以用gcc，不过要链接c++的标准库(-lstdc++)，否则会链接失败。 这里实验结果与理论分析的一致。 另外：如果手动设置#pragma pack(4)，后效果如何呢？ 1234567891011121314#pragma pack(4)class Test&#123;public: char c; &#x2F;&#x2F; offset &#x3D; 0x20000000. 区间：[0x20000000,0x2000000] int i; &#x2F;&#x2F;offset &#x3D; min&#123;4,4&#125;的整数倍为0x20000004. 区间：[0x20000004,0x20000007] short s; &#x2F;&#x2F;offset &#x3D; min&#123;4,2&#125;的整数倍,0x20000008. 区间：[0x20000008,0x200009] double d; &#x2F;&#x2F;offset &#x3D; min&#123;4,8&#125;的整数倍,0x2000000C. 区间：[0x2000000C,0x200013] &#x2F;&#x2F;整体占20字节，并且20 为 min&#123;4,8&#125;的整数倍，故对齐，无需在尾部填充占位。 Test()&#123;&#125; ~Test()&#123;&#125; void fff()&#123;&#125;&#125;;#pragma pack() 查看结果是否为sizeof = 20呢？ 显然，是和分析的一致。 6 总结这里以C++的类为例，进行内存对齐分析。关于C++的内存布局，以及含有virtual函数的类，实际上还会更复杂。简单的就如最基本的类，这和C中的struct是非常类似的。 掌握C++中类的内存对齐，有助于进一步理解C++对象模型。","categories":[],"tags":[]},{"title":"Makefile入门","slug":"Makefile入门","date":"2020-08-11T14:43:08.000Z","updated":"2020-08-11T15:19:49.388Z","comments":true,"path":"2020/08/11/Makefile入门/","link":"","permalink":"https://tang1129.github.io/2020/08/11/Makefile%E5%85%A5%E9%97%A8/","excerpt":"今天抽空研究了下 Makefile，在这里整理一下各处搜到的资料，以备将来复习时快速上手，同时也帮助和我一样的初学者们节约时间（全文阅读时间不超过20分钟）。","text":"今天抽空研究了下 Makefile，在这里整理一下各处搜到的资料，以备将来复习时快速上手，同时也帮助和我一样的初学者们节约时间（全文阅读时间不超过20分钟）。 首先，假设我们有如下几个代码文件：main.cpp functions.h function1.cpp function2.cpp （代码来自：Using make and writing Makefile(in C++ or C)）。 1234&#x2F;&#x2F; functions.hvoid print_hello();int factorial(int n); 12345678910111213141516&#x2F;&#x2F; function1.cpp#include &quot;functions.h&quot;int factorial(int n)&#123; if (n!&#x3D;1) &#123; return n*factorial(n-1); &#125; else &#123; return 1; &#125; &#125; 1234&#x2F;&#x2F;function2.cpp#include&lt;iostream&gt;#include&lt;&gt; 123456789101112&#x2F;&#x2F;main.cpp# include&lt;iostream&gt;# include &quot;functions.h&quot;int main()&#123; print_hello(); std::cout &lt;&lt; &quot;this is main&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;The factorial of 5 is &quot; &lt;&lt; factorial(5) &lt;&lt; std::endl; return 0;&#125; 不用 makefile 如何编译？如果不用 makefile，则需要按照下面的方式编译上述代码： 1234g++ -c function1.cppg++ -c function2.cppg++ -c main.cppg++ -o hello main.o function1.o function2.o其中， g++ -c function1.cpp 会将源码编译成名为 function1.o 对象文件。如果不想采用默认的命名，也可以自定义文件名，例如： 1g++ -c function1.cpp -o fun1.o。 也可以用一行命令整合编译、链接的步骤： 1g++ -o hello main.cpp function1.cpp function2.cpp 这种方式有很多弊端，例如： 每次编译、链接都需要手动敲的很多命令。 当工程量很大时，编译整个工程需要花很久。而我们往往并不是每次都修改了所有源文件，因此希望程序自动编译那些被修改的源码，而没被修改的部分不要浪费时间重新编译。 为了解决上述第一个问题，我们可以把所有编译需要的命令保存到文件中，编译时一键执行。针对第二个问题，我们希望有一个软件，自动检测哪些源文件被修改过，然后自动把它们挑出来选择性地编译。而 make 命令通过检测代码文件的时间戳，决定是否编译它。 第一版 Makefile首先需要确定 Makefile 的名字，需要设置成 Makefile 或者 makefile，而不能是其它版本（MakeFile, Make_file, makeFile,… )。其次，需要注意的是 Makefile 是缩进敏感的，在行首一定不能随便打空格。下面我们看一下第一版 Makefile。 12345 Makefile (井号为注释)all: g++ -o hello main.cpp function1.cpp function2.cppclean: rm -rf *.o hello （注意上面代码片段的缩进，是一个而不是4个或者8个空格。） 其中 all 、clean的术语为 target，我也可以随意指定一个名字，例如 abc，真正执行编译的是它下面缩进行的命令。我们可以看到，这个命令和我们在命令行中手动敲的没有任何区别。因此，通过这个简单的 Makefile，就可以省去了每次手动敲命令的痛苦：只需要在命令行敲下 make 回车，即可完成编译。 clean 表示清除编译结果，它下方就是普通的命令行删除文件命令。命令行输入 make 将默认执行第一个 target （即 all）下方的命令；如要执行清理操作，则需要输入 make clean，指定执行 clean 这个 target 下方的命令。 这个 Makefile 虽然可以省去敲命令的痛苦，却无法选择性编译源码。因为我们把所有源文件都一股脑塞进了一条命令，每次都要编译整个工程，很浪费时间. 第二版 Makefile 将解决这个问题。 第二版 Makefile既然我们希望能够选择性地编译源文件，就不能像上一节那样把所有源文件放在一条命令里编译了，而是要分开写： 123456789101112all: hellohello: main.o function1.o function2.o g++ main.o function1.o function2.o -o hellomain.o: main.cpp g++ -c main.cppfunction1.o: function1.cpp g++ -c function1.cppfunction2.o: function2.cpp g++ -c function2.cppclean: rm -rf *.o hello 上面的 Makefile 包含了一条重要的语法：:。即，目标：目标依赖的文件。 顺着代码捋一下逻辑： 命令行输入 make ，将默认执行 all 这个 target； 而 all 这个 target 依赖于 hello，hello 在当前目录下并不存在，于是程序开始往下读取命令..……终于找到了 hello 这个 target； 正待执行 hello 这个 target 的时候，却发现它依赖于 main.o，function1.o，function2.o 这三个文件，而它们在当前目录下都不存在，于是程序继续向下执行； 遇到 main.o target，它依赖于 main.cpp。而 main.cpp 是当前目录下存在的文件，终于可以编译了，生成 main.o 对象文件。后面两个函数以此类推，都编译好之后，再回到 hello target，连接各种二进制文件，生成 hello 文件。 第一次编译的时候，命令行会输出： 1234g++ -c main.cppg++ -c function1.cppg++ -c function2.cppg++ main.o function1.o function2.o -o hello 证明所有的源码都被编译了一遍。假如我们对 main.cpp 做一点修改，再重新 make（重新 make 前不要 make clean），则命令行只会显示： 12g++ -c main.cppg++ main.o function1.o function2.o -o hello 这样，我们就发挥出 Makefile 选择性编译的功能了。下面，将介绍如何在 Makefile 中声明变量（declare variable）。 第三版 Makefile我们希望将需要反复输入的命令整合成变量，用到它们时直接用对应的变量替代，这样如果将来需要修改这些命令，则在定义它的位置改一行代码即可。 12345678910111213141516CC &#x3D; g++CFLAGS &#x3D; -c -WallLFLAGS &#x3D; -Wallall: hellohello: main.o function1.o function2.o $(CC) $(LFLAGS) main.o function1.o function2.o -o hellomain.o: main.cpp $(CC) $(CFLAGS) main.cppfunction1.o: function1.cpp $(CC) $(CFLAGS) function1.cppfunction2.o: function2.cpp $(CC) $(CFLAGS) function2.cppclean: rm -rf *.o hello 上面的 Makefile 中，开头定义了三个变量：CC，CFLAGS，和 LFLAGS。其中 CC 表示选择的编译器（也可以改成 gcc）；CFLAGS 表示编译选项，-c 即 g++ 中的 -c，-Wall 表示显示编译过程中遇到的所有 warning；LFLAGS 表示链接选项，它就不加 -c 了。这些名字都是自定义的，真正起作用的是它们保存的内容，因此只要后面的代码正确引用，将它们定义成阿猫阿狗都没问题。容易看出，引用变量名时需要用 $() 将其括起来，表示这是一个变量名。 第四版 Makefile第三版的Makefile 还是不够简洁，例如我们的 dependencies 中的内容，往往和 g++ 命令中的内容重复： 12hello: main.o function1.o function2.o $(CC) $(LFLAGS) main.o function1.o function2.o -o hello 我们不想敲那么多字，能不能善用 : 中的内容呢？这就需要引入下面几个特殊符号了（也正是这些特殊符号，把 Makefile 搞得像是天书，吓退了很多初学者）：$@ ，$&lt;，$^。 例如我们有 target: dependencies 对：all: library.cpp main.cpp $@ 指代 all ，即 target $&lt; 指代 library.cpp， 即第一个 dependency $^ 指代 library.cpp 和 main.cpp，即所有的 dependencies 因此，本节开头的 Makefile 片段可以改为： 12hello: main.o function1.o function2.o $(CC) $(LFLAGS) $^ -o $@ 而第四版 Makefile 就是这样的： 12345678910111213141516CC &#x3D; g++CFLAGS &#x3D; -c -WallLFLAGS &#x3D; -Wallall: hellohello: main.o function1.o function2.o $(CC) $(LFLAGS) $^ -o $@main.o: main.cpp $(CC) $(CFLAGS) $&lt;function1.o: function1.cpp $(CC) $(CFLAGS) $&lt;function2.o: function2.cpp $(CC) $(CFLAGS) $&lt;clean: rm -rf *.o hello 但是手动敲文件名还是有点麻烦，能不能自动检测目录下所有的 cpp 文件呢？此外 main.cpp 和 main.o 只差一个后缀，能不能自动生成对象文件的名字，将其设置为源文件名字后缀换成 .o 的形式？ 第五版 Makefile想要实现自动检测 cpp 文件，并且自动替换文件名后缀，需要引入两个新的命令：patsubst 和 wildcard。 5.1 wildcardwildcard 用于获取符合特定规则的文件名，例如下面的代码： 1234SOURCE_DIR &#x3D; . # 如果是当前目录，也可以不指定SOURCE_FILE &#x3D; $(wildcard $(SOURCE_DIR)&#x2F;*.cpp)target: @echo $(SOURCE_FILE) make 后发现，输出的为当前目录下所有的 .cpp 文件： 1.&#x2F;function1.cpp .&#x2F;function2.cpp .&#x2F;main.cpp 其中 @echo 前加 @是为了避免命令回显，上文中 make clean 调用了 rm -rf 会在 terminal 中输出这行命令，如果在 rm 前加了 @ 则不会输出了。 5.2 patsubst patsubst 应该是 pattern substitution 的缩写。用它可以方便地将 .cpp 文件的后缀换成 .o。它的基本语法是：$(patsubst 原模式，目标模式，文件列表)。运行下面的示例： 12345 SOURCES &#x3D; main.cpp function1.cpp function2.cppOBJS &#x3D; $(patsubst %.cpp, %.o, $(SOURCES))target: @echo $(SOURCES) @echo $(OBJS) 输出的结果为： 12main.cpp function1.cpp function2.cppmain.o function1.o function2.o 5.3 综合两个命令 综合上述两个命令，我们可以升级到第五版 Makefile： 1234567891011121314151617181920212223OBJS &#x3D; $(patsubst %.cpp, %.o, $(wildcard *.cpp))CC &#x3D; g++CFLAGS &#x3D; -c -WallLFLAGS &#x3D; -Wallall: hellohello: $(OBJS) $(CC) $(LFLAGS) $^ -o $@main.o: main.cpp $(CC) $(CFLAGS) $&lt; -o $@function1.o: function1.cpp $(CC) $(CFLAGS) $&lt; -o $@function2.o: function2.cpp $(CC) $(CFLAGS) $&lt; -o $@clean: rm -rf *.o hello&#96;&#96;&#96; 然而这一版的 Makefile 还有提升空间，它的 main.o，function1.o，function2.o 使用的都是同一套模板，不过换了个名字而已。第六版的 Makefile 将处理这个问题。### 第六版 Makefile这里要用到 Static Pattern Rule，其语法为： targets: target-pattern: prereq-patterns 123其中 targets 不再是一个目标文件了，而是一组目标文件。而 target-pattern 则表示目标文件的特征。例如目标文件都是 .o 结尾的，那么就将其表示为 %.o，prereq-patterns (prerequisites) 表示依赖文件的特征，例如依赖文件都是 .cpp 结尾的，那么就将其表示为 %.cpp. 通过上面的方式，可以对 targets 列表中任何一个元素，找到它对应的依赖文件，例如通过 targets 中的 main.o，可以锁定到 main.cpp。下面是第六版的 Makefile OBJS = $(patsubst %.cpp, %.o, $(wildcard *.cpp))CC = g++CFLAGS = -c -WallLFLAGS = -Wall all: hellohello: $(OBJS) $(CC) $(LFLAGS) $^ -o $@$(OBJS):%.o:%.cpp $(CC) $(CFLAGS) $&lt; -o $@ clean: rm -rf *.o hello 123#### 杂看到有的 Makefile 设置了 -lm 的 flag，查阅资料发现表示连街 math 库，因为代码中可能 #include&lt;math.h&gt; 。例如 g++ -o out fun.cpp -lm CC = g++LIBS = -lmout: fun.cpp $(CC) -o $@ $^ $(LIBS) ``` 总结本文介绍了如何写 Makefile，主要的知识点有： 在 Makefile 中定义变量并引用 $^，$@，$&lt; 的含义 wildcard，patsubst 的用法 static pattern rule：targets: target-pattern: prereq-patterns 感谢阅读，希望各位朋友能有收获。","categories":[],"tags":[]},{"title":"线程死锁问题","slug":"线程死锁问题","date":"2020-08-11T10:37:41.000Z","updated":"2020-08-11T10:45:48.620Z","comments":true,"path":"2020/08/11/线程死锁问题/","link":"","permalink":"https://tang1129.github.io/2020/08/11/%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/","excerpt":"• 什么是线程死锁？• 死锁如何产生？• 如何避免线程死锁？本文便就此问题进行分析，将用尽可能通俗的语言由浅入深地帮助大家理解死锁，了解其产生的原理与对应的解决方案。","text":"• 什么是线程死锁？• 死锁如何产生？• 如何避免线程死锁？本文便就此问题进行分析，将用尽可能通俗的语言由浅入深地帮助大家理解死锁，了解其产生的原理与对应的解决方案。 什么是线程死锁线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行。当线程进入对象的 synchronized 代码块时，便占有了资源，直到它退出该代码块或者调用 wait 方法，才释放资源，在此期间，其他线程将不能进入该代码块。当线程互相持有对方所需要的资源时，会互相等待对方释放资源，如果线程都不主动释放所占有的资源，将产生死锁。 死锁如何产生场景一星期日早上十点半，你在公路上开车，这是一条窄路，只能容纳一辆车。这时，迎面又驶来一辆车，你们都走到一半，谁也不想倒回去，于是各不相让，陷入无尽的等待。场景二你和她吵架了，谁也不理谁，甚至晚饭时间都各自煮饭。你在炒京酱肉丝，她在做葱烤鲫鱼。炒到一半你发现小葱被她全部拿走了，于是你默默等待她做好菜后再去拿，殊不知她也在等待你炒完菜后来拿酱油。场景三你和四个好朋友坐在圆形餐桌旁，你们只做两件事情：吃饭，或者思考。吃饭的时候，你们就停止思考。思考的时候，也停止吃饭。每个人面前有一碗兰州拉面，并且每个人左右两边各有一根筷子。你们必须要拿到两根筷子才能开始吃面。吃完后再放下筷子，让别人可以使用。吃了一会之后，每个人都拿起了自己左手边的筷子，导致每个人都只有一根筷子，并且等待别人吃完放下筷子给自己。可惜，没有人吃到面，所以没有人会放下筷子。（著名的哲学家就餐问题）场景四你有两个线程 A 和 B ，各自在加锁的状态下运行。A 持有一部分资源，并且等待 B 线程中的资源以完成自己的工作，而此时 B 线程也在等待 A 中的资源以完成自己的工作。由于他们都是锁定状态，所以他们必须完成了自己的工作后，自己持有的资源才能释放。于是线程无休止地等待，导致死锁。代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142public class JavaTest &#123; @Test public void test() &#123; final Object lockA &#x3D; new Object(); final Object lockB &#x3D; new Object(); new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (lockA) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (lockB) &#123; &#125; System.out.println(&quot;finish A&quot;); &#125; &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (lockB) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (lockA) &#123; &#125; System.out.println(&quot;finish B&quot;); &#125; &#125; &#125;).start(); try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 此程序中，线程 A 持有 lockA 对象，并请求 lockB 对象；线程 B 持有 lockB 对象，并请求 lockA 对象。由于他们都在等待对方释放资源，所以会产生死锁。运行程序，将发现控制台无法打印出 “finish A” 和 “finish B” 消息。这些都是程序员在工作或生活中会遇到的问题，人生就像是一个进程，时间是我们的主线程，期间做的每一件事都是开启的一个子线程。当多件事冲突时，并发问题就产生了。上述问题都指向同一类并发问题：死锁。 产生死锁的的四个条件：1、互斥条件：一个资源每次只能被一个进程使用；2、请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放；3、不剥夺条件：进程已获得的资源，在没使用完之前，不能强行剥夺；4、循环等待条件：多个进程之间形成一种互相循环等待资源的关系。并发带来压力，有的人或有的程序，会因为承受不住压力而崩溃，情绪崩溃和程序崩溃没什么两样。当然，不论是做人还是写程序，面对问题时，正确的做法都应是采取策略，解除死锁。 如何避免线程死锁方案一你想起书中所言：退一步海阔天空。但你也深知公平好过忍让。正值周赛时间，你摇下车窗，对对面的兄弟喊道：咱来比赛一场力扣周赛，谁输了谁倒出去让另一个人过吧！于是你们打开力扣，开始答题。半小时后，你凭借高超的代码水平 AC 了全部题目。对面司机对你拱手道：技不如人，甘拜下风。于是他倒了回去，让出了自己的一半路。最终你们都得以顺利通行。方案二你在炒菜时发现没有小葱，于是你换位思考，想到她会不会也缺少自己用着的材料。虽然她还在和你冷战，但你劝解自己一个大老爷们不应该和女孩子置气，于是你主动把自己用着的所有材料拿给了她。她感受到你设身处地为她着想，大为感动，你们和好如初。之后她为你们两个人一起炒了京酱肉丝和葱烤鲫鱼。方案三你和你的朋友们决定给筷子编上号：1~5。规定每个人拿筷子时必须先拿到自己两边的筷子中号码小的那一根，再去拿号码大的那一根。如果小的那一根没有拿到，不能先拿大的。当你们开始吃饭时，由于数字 5 不可能被一个人单独拿到。因为他旁边的另一根筷子编号必定比 5 小，所以不会再出现每个人都拿着一根的无限等待情形。方案四你在运行两个线程前，预先将线程 A 和 B 中的资源拷贝一份，让他们不需互相等待对方的资源，于是两个线程都得以顺利运行。这四种方案分别破坏了上述四个条件之一。这也是解决死锁问题的四种方法：1、破坏不剥夺条件：让对面的司机放弃了自己已有的资源。2、破坏请求与保持条件：在自己需要的材料缺少时，主动放弃自己持有的资源，防止出现互相等待。3、破坏循环等待条件：由于筷子指定了编号和获取规则，所以每个锁定状态都将按照顺序执行，于是便杜绝了环路等待条件。4、破坏互斥条件：由于每次使用时都拷贝一份，所以一个资源可以被多个进程使用。 事实上，使用预先拷贝资源解决死锁问题的方案一般并不常用。这是由于拷贝的成本往往很大，并且影响效率。实际工作中较常采用的是第三种方案，通过控制加锁顺序解决死锁：• 加锁顺序：当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。当然这种方式需要你事先知道所有可能会用到的锁，然而总有些时候是无法预知的。除此之外，我们还可以通过设置加锁时限或添加死锁检测避免死锁：• 加锁时限：加上一个超时时间，若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。但是如果有非常多的线程同一时间去竞争同一批资源，就算有超时和回退机制，还是可能会导致这些线程重复地尝试但却始终得不到锁。死锁检测：死锁检测即每当一个线程获得了锁，会在线程和锁相关的数据结构中（ map 、 graph 等）将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。","categories":[],"tags":[{"name":"线程死锁","slug":"线程死锁","permalink":"https://tang1129.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81/"}]},{"title":"linux下的动态链接库问题","slug":"linux下的动态链接库问题","date":"2020-08-11T10:15:55.000Z","updated":"2020-08-11T10:45:46.734Z","comments":true,"path":"2020/08/11/linux下的动态链接库问题/","link":"","permalink":"https://tang1129.github.io/2020/08/11/linux%E4%B8%8B%E7%9A%84%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E9%97%AE%E9%A2%98/","excerpt":"在 Linux 开发时，我们经常会看到一些形如 xxx.so 的名称出现，其中 so 是 Shared Object 的缩写，即可以共享的目标文件，也就是我们所称为的动态链接库，和在 Windows 下大家玩游戏时遇到的 xxx.dll 错误中的文件是一个类型的。","text":"在 Linux 开发时，我们经常会看到一些形如 xxx.so 的名称出现，其中 so 是 Shared Object 的缩写，即可以共享的目标文件，也就是我们所称为的动态链接库，和在 Windows 下大家玩游戏时遇到的 xxx.dll 错误中的文件是一个类型的。 以下问题：• 怎么创建一个动态库？• 动态库文件的后缀名是什么？• 怎么使用一个动态库？• 动态库的命名规范？• 系统默认的动态库的查找路径？• 动态库显示连接所使用的系统库是什么？ 一、什么是库库是写好的现有的，成熟的，可以复用的代码。现实中每个程序都要依赖很多基础的底层库，不可能每个人的代码都从零开始，因此库的存在意义非同寻常。本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。库有两种：• 静态库（.a、.lib）• 动态库（.so、.dll）在一个程序的编译过程中，分为以下几个步骤：预处理，编译，汇编，链接。本文中讨论的链接库就是针对最后一个步骤「链接」而言的。 动态库和静态库的区别左图为静态链接库，右图为动态链接库 对于静态链接库而言在链接阶段，会将汇编生成的「目标文件.o」与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接： • 静态链接库对函数库的链接是放在编译时期完成的。程序在运行时与函数库就没有了任何的联系。 • 它比较浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。 • 静态库对程序的更新和发布也会带来麻烦。如果静态库更新了，所有使用它的应用程序都需要重新编译、部署、发布给用户。静态链接可以理解为最后生成了一个「单文件免安装绿色版」的程序，优点在于移植的时候只需要移动这一个文件，缺点在于文件体积非常大，为了解决这样的问题，就有了动态链接库。动态链接库在程序编译时并不会被连接到目标代码中，而是在程序运行时才被载入。 • 不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，可以实现进程之间的资源共享。（因此动态库也称为共享库）规避了空间浪费问题。 • 动态库在程序运行时才被载入，也解决了静态库对程序的更新、部署和发布带来的麻烦。用户只需要更新动态库即可将一些程序升级变得简单，增量更新。动态库连接到系统空间，如果多个程序连接了同一个库，那么只需要一份，优点在于编译程序的时候不会将对应的库文件全部打包在生成的程序中，而是保留了到对应库的链接，缺点就是移植的时候如果只移动了对应的程序没有安装相关的库的话，就会看到类似以下喜闻乐见的结果了。 在 Linux 下一个动态库有y三个不同名字的文件组成：• soname 文件lib + 链接库名字 + .so + .版本号• real name 文件lib + 链接库名字 + .so + .版本号.次版本号.发行号• linker name 文件lib + 链接库名字 + .so当程序在内部列出所需要的链接库时，仅仅使用 soname。当你创建一个链接库时，使用 real name。安装一个新的链接库时，把它复制到一个DLL文件夹里，然后运行程序 ldconfig。ldconfig 检查存在的 real name 文件，并且创建指向它符号链接 soname 文件。可能大家比较常见到的有 libsodium 等。 二、创建一个动态库有了上面关于库的一些基础知识之后，我们可以开始尝试创建一个动态库来供程序使用了。比如我们有一个求最大值的函数 max(int a,int b,int c) ，放在文件 max.c 中文件内容如下： int max(int a, int b, int c) { int max = ( a &lt; b ) ? b : a; return ( ( max &lt; c ) ? c : max ); }可以通过： gcc -fPIC -shared -o libmax.so max.c将其编译为共享库，-fPIC 是编译选项，PIC 是 Position Independent Code 的缩写，表示要生成位置无关的代码，这是动态库需要的特性；-shared 是链接选项，告诉gcc生成动态库而不是可执行文件。为了让用户知道我们的动态库中有哪些接口可用，我们需要编写对应的头文件，比如可以写一个 max.h ： #ifndef __MAX_H__ #define __MAX_H__ int max(int a, int b, int c); #endif设置一个驱动函数来测试我们编写的动态库： #include &lt;stdio.h&gt; #include &quot;max.h&quot; int main(int argc, char *argv[]) { int a = 12, b = -2, c = 120; printf(&quot;The max value of 12, -2 and 120 is %d.\\n&quot;, max(a, b, c)); return 0; }通过 gcc test.c -L. -lmax 来生成 a.out，其中-lmax表示要链接 libmax.so，-L. 表示搜索要链接的库文件时包含当前路径。同一目录下同时存在同名的动态库和静态库，比如 libmax.so 和 libmax.a 都在当前路径下，则gcc会优先链接动态库。但是这样直接运行的话，会出现一个错误： ./a.out: error while loading shared libraries: libmax.so: cannot open shared object file: No such file or directory由于 Linux 是通过/etc/ld.so.cache文件搜寻要链接的动态库的，而/etc/ld.so.cache是 ldconfig 程序读取/etc/ld.so.conf文件生成的，本次使用的动态库libmax.so并不在对应的目录下，就会导致程序无法找到对应的动态链接库，这样我们的解决方法有二：• 如果仅仅是本地使用，可以在编译后指定一个环境变量：LD_LIBRARY_PATH=. ./a.out ，这样程序会在本地寻找• 如果需要在系统层面共享这个库，可以把 libmax.so 所在的路径添加到 /etc/ld.so.conf 中，再以 root 权限运行 ldconfig 程序，更新 /etc/ld.so.cache具体采用的方法因使用场景而异，如果仅仅是测试用途的话，可以直接使用添加环境变量的方式解决。","categories":[],"tags":[{"name":"linux 动态链接","slug":"linux-动态链接","permalink":"https://tang1129.github.io/tags/linux-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"}]},{"title":"linux下软链接和硬链接的区别","slug":"linux下软链接和硬链接的区别","date":"2020-04-11T09:26:40.000Z","updated":"2020-08-11T10:36:24.432Z","comments":true,"path":"2020/04/11/linux下软链接和硬链接的区别/","link":"","permalink":"https://tang1129.github.io/2020/04/11/linux%E4%B8%8B%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"在 Linux 系统中，一切都是文件，然而为了区分不同类型的事物，我们有了：• 普通文件• 目录文件• 链接文件• 设备文件 文件描述符（file descriptor） 是内核为了高效管理已被打开的文件所创建的索引，其值是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行 I/O 操作的系统调用都通过文件描述符。","text":"在 Linux 系统中，一切都是文件，然而为了区分不同类型的事物，我们有了：• 普通文件• 目录文件• 链接文件• 设备文件 文件描述符（file descriptor） 是内核为了高效管理已被打开的文件所创建的索引，其值是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行 I/O 操作的系统调用都通过文件描述符。 对于 Linux 有一些使用的用户来说，会有类似如下的写法： 1g++ lots_of_errors 2&gt;&amp;1 | head 其中 2&gt;&amp;1 中的2 就是表示的「标准错误」，1 就是「标准输出」，中间的 &amp; 表示后面跟的数字是文件描述符而不是一个文件（不然所有的「标准错误」就都重定向到了一个名为 1 的文件中了）。本文将针对另一个面试重点进行展开阐述：说说看 Linux 下有哪几种链接？软链接和硬链接？它们之间的区别是什么呢？ Linux 下的链接作为的一个 Linux 的使用者，Linux 系统下提供 ln 指令来进行文件链接，我们一定见过类似如下指令： 1ln -s bar.txt foo.txt 此时如果 ls 查看当前目录下的文件的话，会发现： 1234➜ lltotal 1.2M-rw-rw-r--. 1 Nova Nova 0 Aug 11 14:43 bar.txtlrwxrwxrwx. 1 Nova Nova 7 Aug 11 14:43 foo.txt -&gt; bar.txt 那么这个foo.txt究竟是什么呢？这个就是一个文件链接，文件链接主要分为硬链接和软链接，通过查看ln –help，可以看到一些重要的内容： 12345➜ Desktop ln --help Usage: ln [OPTION]... [-T] TARGET LINK_NAME Create hard links by default, symbolic links with --symbolic. Mandatory arguments to long options are mandatory for short options too. -s, --symbolic make symbolic links instead of hard links ln 指令默认创建的是硬链接，如果加入了-s参数，则会生成一个软链接。 硬链接​先来看看 ln 默认创建的硬链接，由于 Linux 下的文件是通过索引节点（Inode）来识别文件，在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号 (Inode Number)。 在 Linux 中，多个文件名指向同一索引节点是存在的，所以硬连接指通过索引节点来进行的连接，即每一个硬链接都是一个指向对应区域的文件。我们这里创建一个文件foo.txt然后建立一个它的硬链接看看： 12345678➜ vim foo.txt ➜ cat foo.txt LeetCode➜ ln foo.txt bar.txt # 这一步是用来创建硬链接➜ ls -litotal 65526817859 -rw-rw-r--. 2 Nova Nova 9 Sep 19 15:59 bar.txt6817859 -rw-rw-r--. 2 Nova Nova 9 Sep 19 15:59 foo.txt 前面的6817859是文件的 inode，可以简单把它想成 C 语言中的指针，它指向了物理硬盘的一个区块，事实上文件系统会维护一个引用计数，只要有文件指向这个区块，它就不会从硬盘上消失，这里我们会发现，这两个文件拥有相同的 inode，通过查看文件内容也会发现是同一个文件： 12➜ cat bar.txt LeetCode 硬链接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬链接到重要文件,以防止“误删”的功能，由于对应该目录的索引节点有一个以上的连接，假设我们删除了原始的foo.txt文件： 123➜ rm -f foo.txt ➜ cat bar.txt LeetCode 此时文件的内容依然存在，所以只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个链接被删除后，文件的数据块及目录的连接才会被释放，也就是说，文件才会被真正删除 软链接 软链接又叫符号链接，这个文件包含了另一个文件的路径名，例如在上图中，foo.txt 就是 bar.txt 的软连接，bar.txt 是实际的文件，foo.txt包含的是对于 bar.txt 的 inode 的记录。软连接可以是任意文件或目录，可以链接不同文件系统的文件，在对符号文件进行读或写操作的时候，系统会自动把该操作转换为对源文件的操作，但删除链接文件时，系统仅仅删除链接文件，而不删除源文件本身，这一点类似于 Windows 操作系统下的快捷方式。 软链接和硬链接的区别在有了上面的知识后我们就可以简要地回答面试中的问题了：软链接和硬链接的区别是什么？我们来总结一下：","categories":[],"tags":[{"name":"linux 软链接 硬链接","slug":"linux-软链接-硬链接","permalink":"https://tang1129.github.io/tags/linux-%E8%BD%AF%E9%93%BE%E6%8E%A5-%E7%A1%AC%E9%93%BE%E6%8E%A5/"}]},{"title":"深度解读C/C++指针与数组","slug":"深度解读C-C-指针与数组","date":"2020-04-08T15:31:26.000Z","updated":"2020-08-11T10:22:34.610Z","comments":true,"path":"2020/04/08/深度解读C-C-指针与数组/","link":"","permalink":"https://tang1129.github.io/2020/04/08/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E8%AF%BBC-C-%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84/","excerpt":"指针和数组是密切相关的。事实上，指针和数组在很多情况下是可以互换的。例如，一个指向数组开头的指针，可以通过使用指针的算术运算或数组索引来访问数组。今天我们就来聊一聊数组和指针千丝万缕的关系。","text":"指针和数组是密切相关的。事实上，指针和数组在很多情况下是可以互换的。例如，一个指向数组开头的指针，可以通过使用指针的算术运算或数组索引来访问数组。今天我们就来聊一聊数组和指针千丝万缕的关系。 一维数组与指针指针可以用来访问数组，也可以用来改变数组成员，这点与数组本身的下标运算符功能并无区别，请看下面程序演示： 12345678int arr[4] &#x3D; &#123;520,1314,521,3344&#125;;int* p &#x3D; NULL ;p &#x3D; arr ;sfor (int i &#x3D; 0; i &lt; 4; i++)&#123; cout&lt;&lt;*（p+i）&lt;&lt;endl;&#125; 运行结果我们会发现，两个循环打印出来的结果是一样的，这是为什么呢？现在我们一起来探讨一下：首先我们需要知道两个常识： 第一个：数组在内存中存储各元素是物理相连的； 第二个：数组的数组名（在此例中就是arr）代表的就是该数组在内存中的首地址； 我们可以打印arr看一下：cout&lt; 当然你也可以将p指向arr的任何一个元素，比如arr[1]，那么p+1就是指向的arr的第三个元素了，这个大家需要注意；指针和数组能这样互用主要是因为数组的存储是物理连续的，否则是不行的，想链表这种结构就不行； 二维数组与指针同样，二维数组与简单的一维数组类似，只不过，二维数组跟我们见过的矩阵类似。同样数组名也是整块连续内存的首地址，那么指针域二维数组怎么互用呢？我们一起来探究一下:我们看这样几行代码： 12int arr[2][2] &#x3D; &#123;&#123;520,1314&#125;,&#123;521,3344&#125;&#125;; cout&lt;&lt;arr[0]&lt;&lt;arr[1] 运行出来arr[0]和arr[1]都是地址，我们再来看一下存储示意图 原来的一维数组变为二维后，arr[0]，和arr[1]又分别是一个一维数组了，那么arr[0]，和arr[1]就分别是一维数组名了，也即分别表示各自代表的数组的首地址；这就像我们excel中的行一样。不信我们取第一行第二个元素打印看一下就是。 好，明白了这个之后，我们看怎么用指针来表示二维数组呢？还是一样，数组名就是数组的首地址；也即是arr[0][0]的地址。 通过上图我们知道：即使是二维数组，他在物理上还是连续的，只不过我们为了人好看，好理解习惯把它化成方阵，更加直观。所以可以直接将p指向首地址，然后一直讲指针往后移动就可以获取所有元素了。","categories":[],"tags":[{"name":"C 指针 数组","slug":"C-指针-数组","permalink":"https://tang1129.github.io/tags/C-%E6%8C%87%E9%92%88-%E6%95%B0%E7%BB%84/"}]},{"title":"网络基础","slug":"网络基础","date":"2020-04-08T09:51:38.000Z","updated":"2020-08-11T10:08:05.386Z","comments":true,"path":"2020/04/08/网络基础/","link":"","permalink":"https://tang1129.github.io/2020/04/08/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/","excerpt":"OSI参考模型与TCP/IP参考模型","text":"OSI参考模型与TCP/IP参考模型 物理层: 指的是电信号的传递方式，比如现在以太网通用的网线链路层：负责网卡设备的驱动、帧同步（就是说从网线上检测到什么信号算作新帧的开始）、冲突检测（如果检测到冲突就自动重发）、数据差错校验等工作。网络层：负责点到点的传输（这里的“点”指主机或路由器），Internet上的主机通过IP地址来标识，IP协议是构成Internet的基础。传输层：负责端到端的传输（这里的“端”指源主机和目的主机）。传输层可选择TCP或UDP协议。会话层： 解决传输层有一个发送方多个接收方时确定发给谁的问题表示层：解决会话层仅仅是文字的交互，提供多种数据格式的显示功能（编码）应用层：将表示层封装，提供用户接口 什么是协议？双方“约定”好的，按照一定格式传输固定数据 数据包封装应用层数据通过协议栈发到网络上时，每层协议都要加上一个数据首部，称为封装不同的协议层对数据包有不同的称谓，在传输层叫做段，在网络层叫做数据包，在链路层叫做帧 TCP/IP协议族大致可分为三部分 internet协议(IP) 传输控制协议(TCP)和用户数据报协议(UDP) TCP/UDP之上的一组协议，专门开发应用程序，如http、smtp、dns、rtp 传输层协议-TCP传输控制协议(TCP)，一种可靠的面向连接的传输层服务. “三次握手”：类似生活中打电话。 简单理解：客户端：我要对你讲话，你能听到吗；服务端：我能听到；而且我也要对你讲话，你能听到吗；客户端：我也能听到。 ………互相开始通话……… “四次挥手”： 简单理解：客户端：我说完了，我要闭嘴了；服务端：我收到请求，我要闭耳朵了；（客户端收到这个确认，于是安心地闭嘴了。）…….服务端还没倾诉完自己的故事，于是继续唠唠叨叨向客户端说了半天，直到说完为止…….服务端：我说完了，我也要闭嘴了；客户端：我收到请求，我要闭耳朵了；（事实上，客户端为了保证这个确认包成功送达，等待了两个最大报文生命周期后，才闭上耳朵。）（服务端收到这个确认，于是安心地闭嘴了。） 传输层协议-UDP用户数据报文协议（UDP），UDP 提供不可靠的非连接型传输层服务。使用UDP时，不需要建立连接，也不跟踪这些参数，开销小，空间和时间上都具有优势。只需要知道对方的IP地址和端口号，就可以直接发送数据包。但是，能不能到达就不知道了。不可靠，但是传输速度快简单理解：类似生活中邮箱，把信件扔到邮箱中，至于有没有人去看它，没有人在乎。 TCP/IP通讯过程","categories":[],"tags":[{"name":"TCP/IP 网络通信","slug":"TCP-IP-网络通信","permalink":"https://tang1129.github.io/tags/TCP-IP-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}]}],"categories":[],"tags":[{"name":"线程死锁","slug":"线程死锁","permalink":"https://tang1129.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81/"},{"name":"linux 动态链接","slug":"linux-动态链接","permalink":"https://tang1129.github.io/tags/linux-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"},{"name":"linux 软链接 硬链接","slug":"linux-软链接-硬链接","permalink":"https://tang1129.github.io/tags/linux-%E8%BD%AF%E9%93%BE%E6%8E%A5-%E7%A1%AC%E9%93%BE%E6%8E%A5/"},{"name":"C 指针 数组","slug":"C-指针-数组","permalink":"https://tang1129.github.io/tags/C-%E6%8C%87%E9%92%88-%E6%95%B0%E7%BB%84/"},{"name":"TCP/IP 网络通信","slug":"TCP-IP-网络通信","permalink":"https://tang1129.github.io/tags/TCP-IP-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}]}